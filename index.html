<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rounded Dice</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle, #2e1a47 0%, #1a1a2e 100%); }
        canvas { display: block; }
        .instruction {
            position: absolute; top: 30px; width: 100%;
            text-align: center; color: white; font-family: 'Segoe UI', sans-serif;
            text-transform: uppercase; letter-spacing: 3px; opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div class="instruction">Натисніть для кидка</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
    let scene, camera, renderer, dice;
    let isRolling = false;

    // Кути для граней
    const faceRotations = {
        1: { x: 0, y: 0 },
        6: { x: Math.PI, y: 0 },
        2: { x: 0, y: -Math.PI/2 },
        5: { x: 0, y: Math.PI/2 },
        3: { x: -Math.PI/2, y: 0 },
        4: { x: Math.PI/2, y: 0 }
    };

    function createDiceFace(number) {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');

        // Малюємо фон з "м'якими" краями
        const r = 80; // Радіус заокруглення крапок і країв
        ctx.fillStyle = '#ffffff';
        
        // Малюємо заокруглений прямокутник на текстурі
        ctx.beginPath();
        ctx.roundRect(10, 10, 492, 492, 60); 
        ctx.fill();

        // Додаємо легкий градієнт для об'єму грані
        const grad = ctx.createRadialGradient(256, 256, 0, 256, 256, 300);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(220,220,220,1)');
        ctx.fillStyle = grad;
        ctx.fill();

        // Малюємо крапки
        ctx.fillStyle = '#111111';
        const dots = {
            1: [[256, 256]],
            2: [[140, 140], [372, 372]],
            3: [[130, 130], [256, 256], [382, 382]],
            4: [[140, 140], [372, 140], [140, 372], [372, 372]],
            5: [[140, 140], [372, 140], [256, 256], [140, 372], [372, 372]],
            6: [[140, 140], [372, 140], [140, 256], [372, 256], [140, 372], [372, 372]]
        };

        dots[number].forEach(pos => {
            ctx.beginPath();
            ctx.arc(pos[0], pos[1], 45, 0, Math.PI * 2);
            ctx.fill();
        });

        const texture = new THREE.CanvasTexture(canvas);
        texture.anisotropy = 16; // Покращуємо чіткість текстури під кутом
        return texture;
    }

    function init() {
        scene = new THREE.Scene();
        
        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 10); 
        camera.lookAt(0, -0.5, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Порядок сторін: 5, 2, 4, 3, 1, 6
        const materials = [5, 2, 4, 3, 1, 6].map(n => 
            new THREE.MeshStandardMaterial({ 
                map: createDiceFace(n),
                roughness: 0.2,
                metalness: 0.1
            })
        );
        
        // Використовуємо BoxGeometry з високою кількістю сегментів для кращого освітлення
        const geometry = new THREE.BoxGeometry(2, 2, 2, 10, 10, 10);
        dice = new THREE.Mesh(geometry, materials);
        scene.add(dice);

        // Освітлення для підкреслення 3D форм
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const topLight = new THREE.SpotLight(0xffffff, 0.8);
        topLight.position.set(5, 15, 5);
        topLight.castShadow = true;
        scene.add(topLight);

        const sideLight = new THREE.PointLight(0x8000ff, 0.5);
        sideLight.position.set(-10, 5, 5);
        scene.add(sideLight);

        window.addEventListener('mousedown', rollDice);
        window.addEventListener('touchstart', rollDice);
        animate();
    }

    function rollDice() {
        if (isRolling) return;
        isRolling = true;

        const result = Math.floor(Math.random() * 6) + 1;
        const target = faceRotations[result];

        // Анімація стрибка
        gsap.to(dice.position, {
            y: 3.5, duration: 0.7, ease: "power2.out", yoyo: true, repeat: 1
        });

        // Анімація обертання (довго і красиво)
        gsap.to(dice.rotation, {
            x: target.x + (Math.PI * 10), // 5 повних обертів
            y: target.y + (Math.PI * 8),
            z: Math.PI * 4,
            duration: 2.8,
            ease: "expo.out",
            onComplete: () => {
                isRolling = false;
                // Плавне вирівнювання для точності
                gsap.to(dice.rotation, {
                    x: target.x, y: target.y, z: 0, duration: 0.3
                });
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
